<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Treemap可视化与交互</title>
    <style type="text/css">
/* form {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

svg {
  font: 10px sans-serif;
} */
    g[transform]:hover rect
    { 
        fill:blue;
    }
    </style>
    <!-- <script src="https://code.jquery.com/jquery-1.7.2.min.js"></script>
    <script src='https://d3js.org/d3.v4.min.js'></script> -->
</head>

<body>
    <!-- <svg width="2700" height="1500"></svg> -->
    <svg></svg>
    <!-- <form>
        <label><input type="radio" name="mode" value="sumBySize" checked> Size</label>
        <label><input type="radio" name="mode" value="sumByCount"> Count</label>
    </form> -->
    <script src="lib/d3.v6.min.js"></script>
    <script src="lib/d3-array.v3.min.js"></script>
    <script type="text/javascript">
        var count = 0;

        function uid(name) {
            return new Id("O-" + (name == null ? "" : name + "-") + ++count);
        }

        function Id(id) {
            this.id = id;
            this.href = new URL(`#${id}`, location) + "";
        }

        Id.prototype.toString = function() {
            return "url(" + this.href + ")";
        };
    </script>
    <script type="text/javascript">

    
        var color = d3.scaleSequential([8, 0], d3.interpolateMagma)
        var format = d3.format(",d")
        var height = 1060
        var width = 954

        // treemap = data => d3.treemap()
        //         .size([width, height])
        //         .paddingOuter(3)
        //         .paddingTop(19)
        //         .paddingInner(1)
        //         .round(true)
        //     (d3.hierarchy(data)
        //         .sum(d => d.value)
        //         .sort((a, b) => b.value - a.value))

        d3.json("data/newChina.json").then(function(data) {
            
            var treemap = d3.treemap()
                        .size([width, height])
                        .paddingOuter(3)
                        .paddingTop(19)
                        .paddingInner(1)
                        .round(true)

            var root = d3.hierarchy(data)
                        .eachBefore(function(d) { d.value = 1; })
                        .sum(d => d.children ? 0 : 1)
                        .sort((a, b) => b.height - a.height || b.value - a.value)
            
            treemap(root)
            console.log(root)
            const svg = d3.select("svg")
                .attr("viewBox", [0, 0, width, height])
                .style("font", "10px sans-serif");

            const shadow = uid("shadow");

            svg.append("filter")
                .attr("id", shadow.id)
            .append("feDropShadow")
                .attr("flood-opacity", 0.3)
                .attr("dx", 0)
                .attr("stdDeviation", 3);

            const node = svg.selectAll("g")
            .data(d3.group(root, d => d.height))
            .join("g")
                .attr("filter", shadow)
            .selectAll("g")
            .data(d => d[1])
            .join("g")
                .attr("transform", d => `translate(${d.x0},${d.y0})`);

            node.append("title")
                .text(d => `${d.ancestors().reverse().map(d => d.data.name).join("/")}\n${format(d.value)}`);

            node.append("rect")
                .attr("id", d => (d.nodeUid = uid("node")).id)
                .attr("fill", d => color(d.height))
                .attr("width", d => d.x1 - d.x0)
                .attr("height", d => d.y1 - d.y0);

            node.append("clipPath")
                .attr("id", d => (d.clipUid = uid("clip")).id)
            .append("use")
                .attr("xlink:href", d => d.nodeUid.href);

            node.append("text")
                .attr("clip-path", d => d.clipUid)
            .selectAll("tspan")
            .data(d => d.data.name.split(/(?=[A-Z][^A-Z])/g).concat(format(d.value)))
            .join("tspan")
                .attr("fill-opacity", (d, i, nodes) => i === nodes.length - 1 ? 0.7 : null)
                .text(d => d);

            node.filter(d => d.children).selectAll("tspan")
                .attr("dx", 3)
                .attr("y", 13);

            node.filter(d => !d.children).selectAll("tspan")
                .attr("x", 3)
                .attr("y", (d, i, nodes) => `${(i === nodes.length - 1) * 0.3 + 1.1 + i * 0.9}em`);

            return svg.node();
        });
        
        
        
        
        
        // var svg = d3.select("svg"),
        //     width = +svg.attr("width"),
        //     height = +svg.attr("height");
        // console.log(width + "---" + height);
        // var fader = function(color) { return d3.interpolateRgb(color, "#fff")(0.2); },
        //     color = d3.scaleSequential([8, 0], d3.interpolateMagma)
        //     format = d3.format(",d");

        // var treemap = d3.treemap()
        //     .tile(d3.treemapResquarify)
        //     .size([width, height])
        //     .round(true)
        //     .paddingInner(1);

        // d3.json("data/newChina.json", function(error, data) {
        // if (error) throw error;

        // var root = d3.hierarchy(data)
        //     .eachBefore(function(d) { d.data.id = (d.parent ? d.parent.data.id + "." : "") + d.data.name; })
        //     .sum(sumByCount)
        //     .sort(function(a, b) { return b.height - a.height || b.value - a.value; });

        // treemap(root);

        // var cell = svg.selectAll("g")
        //     .data(root.leaves())
        //     .enter().append("g")
        //     .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; });

        // cell.append("rect")
        //     .attr("id", function(d) { return d.data.id; })
        //     .attr("width", function(d) { return d.x1 - d.x0; })
        //     .attr("height", function(d) { return d.y1 - d.y0; })
        //     .attr("fill", function(d) { return color(d.parent.data.id); });

        // cell.append("clipPath")
        //     .attr("id", function(d) { return "clip-" + d.data.id; })
        //     .append("use")
        //     .attr("xlink:href", function(d) { return "#" + d.data.id; });

        // cell.append("text")
        //     .attr("clip-path", function(d) { return "url(#clip-" + d.data.id + ")"; })
        //     .selectAll("tspan")
        //     .data(function(d) { return d.data.name.split(/(?=[A-Z][^A-Z])/g); })
        //     .enter().append("tspan")
        //     .attr("x", 4)
        //     .attr("y", function(d, i) { return 13 + i * 10; })
        //     .text(function(d) { return d; });

        // cell.append("title")
        //     .text(function(d) { return d.data.id + "\n" + format(d.value); });

        // d3.selectAll("input")
        //     .data([sumBySize, sumByCount], function(d) { return d ? d.name : this.value; })
        //     .on("change", changed);

        // var timeout = d3.timeout(function() {
        //     d3.select("input[value=\"sumByCount\"]")
        //         .property("checked", true)
        //         .dispatch("change");
        // }, 2000);

        // function changed(sum) {
        //     timeout.stop();

        //     treemap(root.sum(sum));

        //     cell.transition()
        //         .duration(750)
        //         .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; })
        //     .select("rect")
        //         .attr("width", function(d) { return d.x1 - d.x0; })
        //         .attr("height", function(d) { return d.y1 - d.y0; });
        // }
        // });

        // function sumByCount(d) {
        // return d.children ? 0 : 1;
        // }

        // function sumBySize(d) {
        // return d.size;
        // }
    </script>

</body>
</html>



